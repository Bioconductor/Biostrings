%\VignetteIndexEntry{How to efficiently use matchPattern() and matchPDict() for fast genome searching}
%\VignetteKeywords{DNA, RNA, Sequence, Biostrings, Sequence alignment} 
%\VignettePackage{Biostrings}

%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
\documentclass[11pt]{article}

%\usepackage{pstricks}
%\usepackage[authoryear,round]{natbib}
\usepackage{hyperref}
\usepackage{underscore}

\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}


\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\textwidth=6.2in

\bibliographystyle{plainnat}
 
\begin{document}
%\setkeys{Gin}{width=0.55\textwidth}

\title{How to efficiently use \Rmethod{matchPattern} and \Rmethod{matchPDict}
       for fast genome searching}
\author{Herv\'e Pag\`es}
\maketitle

\tableofcontents


% ---------------------------------------------------------------------------

\section{The Biostrings-based genome data packages}

The Bioconductor project provides data packages that contain the full genome
of a given organism. These packages are called {\it Biostrings-based genome
data packages} because the sequences they contain are stored in the basic
containers defined in the \Rpackage{Biostrings} package (i.e. the
\Rclass{DNAString} and \Rclass{BStringViews} classes).
Except for the data they contain, all the Biostrings-based genome data
packages are very similar and can be manipulated in an easy and consistent
way. This is achieved by defining and sharing their basic functionalies
in the infrastructure package \Rpackage{BSgenome} that they all depend on.
This is the reason why they are also known as the {\it BSgenome data packages}.

See the \Rfunction{available.genomes} man page (\Rfunction{?available.genomes})
in \Rpackage{BSgenome} for more information about how to get the list of
all the {\it Biostrings-based genome data packages} currently available
in your version of Bioconductor.

More genomes can be added if necessary. Note that the process of making a
{\it Biostrings-based genome data package} is not yet documented but you
are welcome to ask for help on the bioc-devel mailing
(\url{http://bioconductor.org/docs/mailList.html}).



% ---------------------------------------------------------------------------

\section{Find arbitrary patterns in a chromosome}

In this section we show how to find some arbitrary patterns in
{\it Caenorhabditis elegans} chromosome I.
UCSC provides several versions of the C. elegans genome: ce1, ce2 and ce4.
These versions correspond to different genome releases from WormBase:
respectively WS100, WS120 and WS170.
See \url{http://genome.ucsc.edu/FAQ/FAQreleases#release1} for the list
of all UCSC genome releases and for the correspondance between UCSC
versions and release names.

The {\it Biostrings-based genome data packages} for the ce2 genome is
\Rpackage{BSgenome.Celegans.UCSC.ce2}. Note that ce1 and ce4 are not
available in Bioconductor but they could be added if there is demand for
them.

See \Rfunction{?available.genomes} for how to install
\Rpackage{BSgenome.Celegans.UCSC.ce2}.
Then load the package and display the single object defined in it:
<<b1>>=
library(BSgenome.Celegans.UCSC.ce2)
ls("package:BSgenome.Celegans.UCSC.ce2")
Celegans
@

\Robject{Celegans} is a \Rclass{BSgenome} object:
<<b2>>=
class(Celegans)
@

When displayed, some basic information about the origin of the
genome is shown (organism, provider, provider version, etc...)
followed by the index of {\it single} sequences and eventually
an additional index of {\it multiple} sequences.
Methods (adequately called {\it accessor methods}) are defined
for individual access to this information:
<<b3>>=
organism(Celegans)
provider(Celegans)
providerVersion(Celegans)
seqnames(Celegans)
mseqnames(Celegans)
@

See the man page for the \Rclass{BSgenome} class (\Rfunction{?BSgenome})
for a complete list of accessor methods and their descriptions.

Now we are ready to display chromosome I:
<<b4>>=
Celegans$chrI
@

Note that this chrI sequence corresponds to the {\it forward} strand
(aka {\it direct} or {\it sense} or {\it positive} or {\it plus} strand)
of chromosome I.
UCSC, and genome providers in general, don't provide files containing the
nucleotide sequence of the {\it reverse} strand (aka {\it indirect}
or {\it antisense} or {\it negative} or {\it minus} or {\it opposite} strand)
of the chromosomes because these sequences can be deduced from the {\it forward}
sequences by taking their reverse complements.
The {\it Biostrings-based genome data packages} are no exceptions: they only
provide the {\it forward} strand sequence of every chromosome.
See \Rfunction{?reverseComplement} for more details about the reverse
complement of a \Rclass{DNAString} object.
It is important to remember that, in practice, the {\it reverse} strand
sequence is almost never needed.
The reason is that, in fact, a {\it reverse} strand analysis
can (and should) always be transposed into a {\it forward} strand analysis.
Therefore trying to compute the {\it reverse} strand sequence of an entire
chromosome by applying \Rfunction{reverseComplement} to its {\it forward}
strand sequence is almost always a bad idea.
See the {\it Find arbitrary patterns in a genome} section of this document
for how to find arbitrary patterns in the {\it reverse} strand of a chromosome.

% It seems like this page http://www.medterms.com/script/main/art.asp?articlekey=20468
% is lying about the noncoding (or coding, they are in fact contradicting themselves)
% nature of the sense and antisense strands.

The number of bases in this sequence can be retrieved with:
<<b5>>=
chrI <- Celegans$chrI
length(chrI)
@

Some basic stats:
<<b6>>=
afI <- alphabetFrequency(chrI)
afI
sum(afI) == length(chrI)
@

Count all exact matches of pattern \Robject{"ACCCAGGGC"}:
<<b7>>=
p <- "ACCCAGGGC"
countPattern(p, chrI)
countPattern(p, chrI, mismatch=1)
@

The matches can be stored in a \Rclass{BStringViews} object
by using the \Rmethod{matchPattern} method:
<<b8>>=
m <- matchPattern(p, chrI, mismatch=1)
m[4:6]
mismatch(p, m[4:6])
@

The \Rmethod{mismatch} method (new in \Rpackage{Biostrings}~2)
returns the positions of the mismatching letters.

Note: The \Rmethod{mismatch} method is in fact a particular case
of a (vectorized) {\it alignment} function where only ``replacements''
are allowed. Current implementation is slow but this will change.


It may happen that a match is {\it out of limits} like in this example:
<<b9>>=
p2 <- DNAString("AAGCCTAAGCCTAAGCCTAA")
m2 <- matchPattern(p2, chrI, mismatch=2)
m2[1:4]
p2 == m2[1:4]
mismatch(p2, m2[1:4])
@

The list of exact matches and the list of inexact matches
can both be obtained with:
<<b10,results=hide>>=
m2[p2 == m2]
m2[p2 != m2]
@

Note that the length of \Robject{m2[p2 == m2]} should be
equal to \Robject{countPattern(p2, chrI, mismatch=0)}.


% ---------------------------------------------------------------------------

\section{Find arbitrary patterns in a genome}

Now we want to extend our analysis to the {\it forward} and {\it reverse}
strands of all the C. elegans chromosomes.
More precisely, here is the analysis we want to perform:

\begin{itemize}

  \item{The input dictionary: }
  Our input is a dictionary of 50 patterns. Each pattern is a short nucleotide
  sequence of 15 to 25 bases (As, Cs, Gs and Ts only, no Ns).
  It is stored in a FASTA file called \Robject{"ce2dict0.fsa"}.
% ce2dict0.fsa was generated with
%   > set.seed(23)
%   > ce2dict0 <- sapply(1:50, function(i) { x <- Celegans[[sample(seqnames(Celegans), 1)]]; start <- as.integer(runif(1, min=1, length(x)-20)); end <- start + as.integer(runif(1, min=14, max=25)); x <- subBString(x, start, end); if (sample(1:2, 1) == 2) x <- reverseComplement(x); as.character(x) })
%   > names(ce2dict0) <- paste("pattern", 1:50, sep="")
%   > write.BStringViews(BStringViews(ce2dict0, "DNAString"), file="ce2dict0.fsa", format="fasta")
  See the {\it Find all the occurences of a uniform-length pattern dictionary
  in a genome} section of this document for a very efficient way to deal with
  the special case where all the patterns in the input dictionary have the same
  length.

  \item{The target: }
  Our target (or subject) is the {\it forward} and {\it reverse} strands of
  the seven C. elegans chromosomes (14 sequences in total).
  We want to find and report all occurences (or hits) of every pattern
  in the target. Note that a given pattern can have 0, 1 or several hits
  in 0, 1 or 2 strands of 0, 1 or several chromosomes.

  \item{Exact or fuzzy matching? }
  We are interested in exact matches only (for now).

  \item{The output: }
  We want to put the results of this analysis in a file so we can send
  it to our collaborators for some post analysis work.
  Our collaborators are not necessarily familiar with R or Bioconductor
  so dumping a high-level R object (like a list or a data frame) into an
  .rda file is not an option. For maximum portability (one of our
  collaborators wants to use Microsoft Excel for the post analysis) we
  choose to put our results in a tabulated file where one line describes
  one hit. The columns (or fields) of this file will be (in this order):
  \begin{itemize}
    \item{seqname: }
    the name of the chromosome where the hit occurs.
    \item{start: }
    an integer giving the starting position of the hit.
    \item{end: }
    an integer giving the ending position of the hit.
    \item{strand: }
    a plus (\Robject{+}) for a hit in the positive strand
    or a minus (\Robject{-}) for a hit in the negative strand.
    \item{patternID: }
    we use the unique ID provided for every pattern in the
    \Robject{"ce2dict0.fsa"} file.
  \end{itemize}

\end{itemize}

Let's start by loading the input dictionary with:
<<c1>>=
ce2dict0_file <- system.file("extdata/ce2dict0.fsa", package="Biostrings")
ce2dict0 <- read.BStringViews(ce2dict0_file, "fasta", subjectClass="DNAString")
@

We can display the number of patterns in the dictionary, the first five
patterns, and the first five pattern IDs with:
<<c2>>=
length(ce2dict0)
ce2dict0[1:5]
desc(ce2dict0)[1:5]
@

Here is how we can write the functions that will perform our analysis:
<<c3,keep.source=TRUE>>=
writeHitHeader <- function(file="")
{
    cat("seqname", "start", "end", "strand", "patternID", file=file, sep="\t")
    cat("\n", file=file, append=TRUE)
}

writeHits <- function(seqname, matches, strand, file="")
{
    for (i in seq_len(length(matches))) {
        cat(seqname, start(matches)[i], end(matches)[i], strand, desc(matches)[i],
            file=file, sep="\t", append=TRUE)
        cat("\n", file=file, append=TRUE)
    }
}

runAnalysis1 <- function(dict0, outfile="")
{
    library(BSgenome.Celegans.UCSC.ce2)
    seqnames <- seqnames(Celegans)
    seqnames_in1string <- paste(seqnames, collapse=", ")
    cat("Target: ", providerVersion(Celegans),
        " chromosomes ", seqnames_in1string, "\n", sep="")
    if (outfile != "")
        writeHitHeader(file=outfile)
    for (seqname in seqnames) {
        subject <- Celegans[[seqname]]
        cat(">>> Finding all hits in chromosome ", seqname, " ...\n", sep="")
        for (i in seq_len(length(dict0))) {
            patternID <- desc(dict0)[i]
            pattern <- dict0[[i]]
            plus_matches <- matchPattern(pattern, subject)
            desc(plus_matches) <- rep(patternID, length(plus_matches))
            writeHits(seqname, plus_matches, "+", file=outfile)
            rcpattern <- reverseComplement(pattern)
            minus_matches <- matchPattern(rcpattern, subject)
            desc(minus_matches)[] <- rep(patternID, length(minus_matches))
            writeHits(seqname, minus_matches, "-", file=outfile)
        }
        cat(">>> DONE\n")
        unload(Celegans, seqname)
    }
}
@

Some important notes about the implementation of the \Rfunction{runAnalysis1}
function:
\begin{itemize}
  \item{}
  \Robject{subject <- Celegans[[seqname]]} is the code that actually loads a
  chromosome sequence into memory.
  After it's not needed anymore, the sequence is removed from memory by
  calling \Robject{unload(Celegans, seqname)}.
  Using only one sequence at a time and unloading it after it's not needed
  anymore is a good practice to avoid memory allocation problems on a machine
  with a limited amount of memory.
  For example, loading all the human chromosome sequences in memory would
  require more than 3GB of memory!

  \item{}
  We have 2 nested \Robject{for} loops: the outer loop walks thru the
  target (7 chromosomes) and the inner loop walks thru the set of
  patterns. Doing the other way around would be very inefficient,
  especially with a bigger number of patterns because this would require
  to load each chromosome sequence into memory as many times as the
  number of patterns.
  Trying to minimize the number of loading/unloading cycles for each
  target sequence during an analysis is good practice because this cycle
  takes a long time.
  The \Rfunction{runAnalysis1} does this only once for each target
  sequence.

  \item{}
  We find the matches in the minus strand (\Robject{minus_matches}) by
  first taking the reverse complement of the current pattern (with
  \Robject{rcpattern <- reverseComplement(pattern)}) and NOT by
  taking the reverse complement of the current subject.
\end{itemize}

Now we are ready to run the analysis and put the results in the
\Robject{"ce2dict0_ana1.txt"} file:
<<c4>>=
runAnalysis1(ce2dict0, outfile="ce2dict0_ana1.txt")
@

Here is some very simple example of post analysis:
\begin{itemize}
  \item{}
Get the total number of hits:
<<c5>>=
hits1 <- read.table("ce2dict0_ana1.txt", header=TRUE)
nrow(hits1)
@
  \item{}
Get the number of hits per chromosome:
<<c6>>=
table(hits1$seqname)
@
  \item{}
Get the number of hits per pattern:
<<c7>>=
hits1_table <- table(hits1$patternID)
hits1_table
@
  \item{}
Get the pattern(s) with the higher number of hits:
<<c8>>=
hits1_table[hits1_table == max(hits1_table)] # pattern(s) with more hits
@
  \item{}
Get the pattern(s) with no hits:
<<c9>>=
setdiff(desc(ce2dict0), hits1$patternID) # pattern(s) with no hits
@
  \item{}
And finally a function that can be used to plot the hits:
<<c10,keep.source=TRUE>>=
plotGenomeHits <- function(bsgenome, seqnames, hits)
{
    ## Retrieve the sequence lengths
    seqlengths <- integer(length(seqnames))
    for (i in seq_len(length(seqnames))) {
        seqname <- seqnames[i]
        seqlengths[i] <- length(bsgenome[[seqname]])
        unload(bsgenome, seqname)
    }
    XMAX <- max(seqlengths)
    YMAX <- length(seqnames)
    plot.new()
    plot.window(c(1, XMAX), c(0, YMAX))
    axis(1)
    axis(2, at=seq_len(length(seqnames)), labels=rev(seqnames), tick=FALSE, las=1)
    ## Plot the chromosomes
    for (i in seq_len(length(seqnames)))
        lines(c(1, seqlengths[i]), c(YMAX + 1 - i, YMAX + 1 - i), type="l")
    ## Plot the hits
    for (i in seq_len(nrow(hits))) {
        seqname <- hits$seqname[i]
        y0 <- YMAX + 1 - match(seqname, seqnames)
        if (hits$strand[i] == "+") {
            y <- y0 + 0.05
            col <- "red"
        } else {
            y <- y0 - 0.05
            col <- "blue"
        }
        lines(c(hits$start[i], hits$end[i]), c(y, y), type="l", col=col, lwd=3)
    }
}
@
Plot the hits found by \Rfunction{runAnalysis1} with:
<<c11,eval=false>>=
plotGenomeHits(Celegans, seqnames(Celegans), hits1)
@
\end{itemize}


% ---------------------------------------------------------------------------

\section{More precautions when using \Rmethod{matchPattern}}

Improper use of \Rmethod{matchPattern} (or \Rmethod{countPattern}) can affect
performance.

If needed, the \Rmethod{matchPattern} and \Rmethod{countPattern} methods
convert their first argument (the pattern) to an object of the same class
than their second argument (the subject) before they pass it to the subroutine
that actually implements the fast search algorithm.

So if you need to reuse the same pattern a high number of times,
it's a good idea to convert it {\it before} to pass it to the
\Rmethod{matchPattern} or \Rmethod{countPattern} method.
This way the conversion is done only once:
<<d1,keep.source=TRUE>>=
library(hgu95av2probe)
tmpseq <- BStringViews(hgu95av2probe$sequence, "DNAString")
someStats <- function(v)
{
    GC <- DNAString("GC")
    CG <- DNAString("CG")
    sapply(1:length(v),
           function(i) {
               y <- v[i]
               c(alphabetFrequency(y)[1:4],
                 GC=countPattern(GC, y),
                 CG=countPattern(CG, y))
           }
    )
}
someStats(tmpseq[1:10])
@

% The above example is Raphael's use case discussed on BioC on Feb 2006.
% In Biostrings 1, the equivalent would be:
% src <- sapply(1:100,
%               function(i) {
%                 paste(sample(c("A","C","G","T"), 25, replace=TRUE),
%                 collapse="")
%               }
%        )
% tmpseq <- DNAString(src)
% someStats <- function(v)
% {
%     GC <- DNAString("GC")
%     CG <- DNAString("CG")
%     sapply(1:length(v),
%            function(i) {
%                y <- v[i]
%                c(alphabetFrequency(y)[2:5],
%                  GC=length(matchDNAPattern(GC, y)),
%                  CG=length(matchDNAPattern(CG, y)))
%            }
%     )
% }
% someStats(tmpseq[1:10])


% ---------------------------------------------------------------------------

\section{Find all the occurences of a uniform-length pattern dictionary in
         a genome}

The \Rfunction{matchPDict} function can be used instead of \Rfunction{matchPattern}
for the kind of analysis described in the {\it Find arbitrary patterns in a genome}
section but it will be much faster (between 100x and 10000x faster depending on the
size of the input dictionary).
Note that a current limitation of \Rfunction{matchPDict} is that it only works with
a dictionary of DNA patterns where all the patterns have the same number of
nucleotides (uniform-length dictionary).
See \Rfunction{?matchPDict} for more information.

Here is how our \Rfunction{runAnalysis1} function can be modified in order to use
\Rfunction{matchPDict} instead of \Rfunction{matchPattern}:
<<e1,keep.source=TRUE>>=
runAnalysis2 <- function(dict0, outfile="")
{
    library(BSgenome.Celegans.UCSC.ce2)
    seqnames <- seqnames(Celegans)
    seqnames_in1string <- paste(seqnames, collapse=", ")
    cat("Target: ", providerVersion(Celegans),
        " chromosomes ", seqnames_in1string, "\n", sep="")
    if (outfile != "")
        writeHitHeader(file=outfile)
    pdict <- new("ULdna_PDict", dict0)
    for (seqname in seqnames) {
        subject <- Celegans[[seqname]]
        cat(">>> Finding all hits in strand + of chromosome ", seqname, " ...\n", sep="")
        plus_matches <- extractMatches(subject, matchPDict(pdict, subject))
        writeHits(seqname, plus_matches, "+", file=outfile)
        cat(">>> DONE\n")
        unload(Celegans, seqname)
    }
    rcdict0 <- reverseComplement(dict0)
    pdict <- new("ULdna_PDict", rcdict0)
    for (seqname in seqnames) {
        subject <- Celegans[[seqname]]
        cat(">>> Finding all hits in strand - of chromosome ", seqname, " ...\n", sep="")
        minus_matches <- extractMatches(subject, matchPDict(pdict, subject))
        writeHits(seqname, minus_matches, "-", file=outfile)
        cat(">>> DONE\n")
        unload(Celegans, seqname)
    }
}
@

Remember that \Rfunction{matchPDict} only works if all the patterns in the
input dictionary have the same length so for this 2nd analysis, we will truncate
the patterns in \Robject{ce2dict0} to 15 nucleotides:
<<e2>>=
ULce2dict0 <- subviews(ce2dict0, 1, 15)
@

Now we can run this 2nd analysis and put the results in the
\Robject{"ULce2dict0_ana2.txt"} file:
<<e3>>=
runAnalysis2(ULce2dict0, outfile="ce2dict0_ana2.txt")
@

\end{document}

