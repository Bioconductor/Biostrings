%\VignetteIndexEntry{Biostrings}
%\VignetteKeywords{DNA, RNA, Sequence, Biostrings, Sequence alignment} 
%\VignettePackage{Biostrings}

%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
\documentclass[11pt]{article}

%\usepackage{pstricks}
%\usepackage[authoryear,round]{natbib}
%\usepackage{hyperref}


\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}


\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\textwidth=6.2in

\bibliographystyle{plainnat} 
 
\begin{document}
%\setkeys{Gin}{width=0.55\textwidth}

\title{Searching a DNA sequence using the
\Rmethod{matchPattern} method (work in progress)}
\author{Herv\'e Pag\`es}
\maketitle

\tableofcontents


% ---------------------------------------------------------------------------

\section{Load a genome}

Load the {\it Caenorhabditis elegans} genome:
<<a1>>=
library(CelegansGenome)
ls(2)
ls(cel)
comment(cel$chrI)
@

Display chromosome I:
<<a2>>=
cel$chrI
@

Note that \Robject{cel\$chrI} is a \Rclass{BStringViews} object with a
single view (\Robject{length(cel\$chrI)} is 1).
The number of letters in this sequence can be retrieved with:
<<a3>>=
cI <- cel$chrI[[1]]
length(cI)
@

Try with an {\it upstream} object:
<<a4>>=
length(cel$upstream2000)
length(cel$upstream2000[[1]])
@

Some basic stats (in \Rpackage{Biostrings}~1 the
\Rmethod{alphabetFrequency} method is implemented in C,
this still needs to be done in \Rpackage{Biostrings}~2):
<<a5>>=
af <- alphabetFrequency(cI)
af
sum(af) == length(cI)
@


% ---------------------------------------------------------------------------

\section{Find patterns in a DNA sequence}

To find all exact matches of pattern \Robject{"ACCCAGGGC"}:
<<b1>>=
p <- "ACCCAGGGC"
countPattern(p, cI)
countPattern(p, cI, mismatch=1)
@

The matches can be stored in a \Rclass{BStringViews} object
by using the \Rmethod{matchPattern} method:
<<b2>>=
m <- matchPattern(p, cI, mismatch=1)
m[4:6]
mismatch(p, m[4:6])
@

The \Rmethod{mismatch} method (new in \Rpackage{Biostrings}~2)
returns the positions of the mismatching letters.

Note: The \Rmethod{mismatch} method is in fact a particular case
of a (vectorized) {\it alignment} function where only ``replacements''
are allowed. Current implementation is slow but (but this will change).


It may happen that a match is {\it out of limits} like here:
<<b3>>=
p2 <- DNAString("AAGCCTAAGCCTAAGCCTAA")
m2 <- matchPattern(p2, cI, mismatch=2)
m2[1:4]
p2 == m2[1:4]
mismatch(p2, m2[1:4])
@

The list of exact matches and the list of inexact matches
can both be obtained with:
<<b4,results=hide>>=
m2[p2 == m2]
m2[p2 != m2]
@

Note that the length of \Robject{m2[p2 == m2]} should be
equal to \Robject{countPattern(p2, cI, mismatch=0)}.


% ---------------------------------------------------------------------------

\section{A note on performance}

If needed, the \Rmethod{matchPattern} and \Rmethod{countPattern} methods
convert their first argument (the pattern) to an object of the same class
than their second argument (the subject) before they pass it to the function
that actually implements the fast search algorithm.

So if you need to reuse the same pattern a high number of times,
it's a good idea to convert it {\it before} to pass it to the
\Rmethod{matchPattern} or \Rmethod{countPattern} method.
This way the conversion is done only once:
<<c1>>=
library(hgu95av2probe)
tmpseq <- BStringViews(hgu95av2probe$sequence, "DNAString")
someStats <- function(v)
{
    GC <- DNAString("GC")
    CG <- DNAString("CG")
    sapply(1:length(v),
           function(i) {
               y <- v[i]
               c(alphabetFrequency(y)[1:4],
                 GC=countPattern(GC, y),
                 CG=countPattern(CG, y))
           }
    )
}
someStats(tmpseq[1:10])
@

% The above example is Raphael's use case discussed on BioC on Feb 2006.
% In Biostrings 1, the equivalent would be:
% src <- sapply(1:100,
%               function(i) {
%                 paste(sample(c("A","C","G","T"), 25, replace=TRUE),
%                 collapse="")
%               }
%        )
% tmpseq <- DNAString(src)
% someStats <- function(v)
% {
%     GC <- DNAString("GC")
%     CG <- DNAString("CG")
%     sapply(1:length(v),
%            function(i) {
%                y <- v[i]
%                c(alphabetFrequency(y)[2:5],
%                  GC=length(matchDNAPattern(GC, y)),
%                  CG=length(matchDNAPattern(CG, y)))
%            }
%     )
% }
% someStats(tmpseq[1:10])
%
% and the someStats() call will be twice faster than with Biostrings 2
% because the alphabetFrequency method has not yet been implemented in C.


\end{document}
