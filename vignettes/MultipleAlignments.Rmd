------------------------------------------------------------------------

---
title: "MultipleAlignment Objects"
author:
- name:|
  Marc Carlson\
  Bioconductor Core Team\
  Fred Hutchinson Cancer Research Center\
  Seattle, WA
- name: "H. Khan"
  affiliation: "Vignette translation from Sweave to Rmarkdown / HTML"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
package: Biostrings
vignette: >
  %\VignetteIndexEntry{Notes for eSet developers}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document
---

# Introduction

The *DNAMultipleAlignment* *RNAMultipleAlignment* and *AAMultipleAlignment* classes allow users to represent groups of aligned DNA, RNA or amino acid sequences as a single object. The frame of reference for aligned sequences is static, so manipulation of these objects is confined to be non-destructive. In practice, this means that these objects contain slots to mask ranges of rows and columns on the original sequence. These masks are then respected by methods that manipulate and display the objects, allowing the user to remove or expose columns and rows without invalidating the original alignment.

# Creation and masking

To create a *MultipleAlignment*, call the appropriate read function to read in and parse the original alignment. There are functions to read clustaW, Phylip and Stockholm data formats.

```{r message=FALSE}
library(Biostrings) 
origMAlign <-
  readDNAMultipleAlignment(filepath =
                             system.file("extdata",
                                         "msx2_mRNA.aln",
                                         package="Biostrings"),
                           format="clustal")

phylipMAlign <-
  readAAMultipleAlignment(filepath =
                          system.file("extdata",
                                      "Phylip.txt",
                                      package="Biostrings"),
                          format="phylip")
```

Rows can be renamed with `rownames`.

```{r}
rownames(origMAlign) 
```

```{r}
rownames(origMAlign) <- c("Human","Chimp","Cow","Mouse","Rat",
                          "Dog","Chicken","Salmon")
origMAlign
```

To see a more detailed version of your *MultipleAlignment* object, you can use the *detail* method, which will show the details of the alignment interleaved and without the rows and columns that you have masked out.

```{r eval=FALSE}
detail(origMAlign) 
```

Applying masks is a simple matter of specifying which ranges to hide.

```{r}
maskTest<- origMAlign
rowmask(maskTest) <- IRanges(start=1,end=3)
rowmask(maskTest) 
maskTest
```

```{r}
colmask(maskTest) <- IRanges(start=c(1,1000),end=c(500,2343))
colmask(maskTest)
```

```{r}
maskTest
```

Remove row and column masks by assigning `NULL`:

```{r}
rowmask(maskTest) <- NULL 
rowmask(maskTest) 
colmask(maskTest) <- NULL 
colmask(maskTest) 
maskTest
```

When setting a mask, you might want to specify the rows or columns to keep, rather than to hide. To do that, use the *invert* argument. Taking the above example, we can set the exact same masks as before by specifying their inverse and using `invert=TRUE`.

```{r}
rowmask(maskTest, invert=TRUE) <- IRanges(start=4,end=8) 
rowmask(maskTest) 
maskTest
colmask(maskTest, invert=TRUE) <- IRanges(start=501,end=999) 
colmask(maskTest) 
maskTest
```

In addition to being able to invert these masks, you can also choose the way in which the ranges you provide will be merged with any existing masks. The *append* argument allows you to specify the way in which new mask ranges will interact with any existing masks. By default, these masks will be the "union" of the new mask and any existing masks, but you can also specify that these masks be the mask that results from when you "intersect" the current mask and the new mask, or that the new mask simply "replace" the current mask. The *append* argument can be used in combination with the *invert* argument to make things even more interesting. In this case, the inversion of the mask will happen before it is combined with the existing mask. For simplicity, I will only demonstrate this on *rowmask*, but it also works for *colmask*. Before we begin, lets set the masks back to being NULL again.

```{r}
## 1st lets null out the masks so we can have a fresh start. 
colmask(maskTest) <- NULL 
rowmask(maskTest) <- NULL
```

Then we can do a series of examples, starting with the default which uses the "union" value for the *append* argument.

```{r}
## Then we can demonstrate how the append argument works 
rowmask(maskTest) <- IRanges(start=1,end=3)
maskTest

rowmask(maskTest,append="intersect") <- IRanges(start=2,end=5) 
maskTest

rowmask(maskTest,append="replace") <- IRanges(start=5,end=8) 
maskTest

rowmask(maskTest,append="replace",invert=TRUE) <- IRanges(start=5,end=8) 
maskTest

rowmask(maskTest,append="union") <- IRanges(start=7,end=8) 
maskTest
```

The function `maskMotif` works on *MultipleAlignment* objects too, and takes the same arguments that it does elsewhere. `maskMotif` is useful for masking occurrences of a string from columns where it is present in the consensus sequence.

```{r}
tataMasked <- maskMotif(origMAlign, "TATA") 
colmask(tataMasked) 
```

`maskGaps` also operates on columns and will mask columns based on the fraction of each column that contains gaps *min.fraction* along with the width of columns that contain this fraction of gaps *min.block.width*.

```{r}
autoMasked <- maskGaps(origMAlign, min.fraction=0.5, min.block.width=4) 
autoMasked
```

Sometimes you may want to cast your *MultipleAlignment* to be a matrix for usage elsewhere. *as.matrix* is supported for these circumstances. The ability to convert one object into another is not very unusual so why mention it? Because when you cast your object, the masks WILL be considered so that the masked rows and columns will be left out of the matrix object.

```{r}
 full = as.matrix(origMAlign) 
 dim(full)
```

```{r}
 partial = as.matrix(autoMasked) 
 dim(partial) 
```

One example of where you might want to use *as.matrix* is when using the [ape]{.sans-serif} package. For example if you needed to use the *dist.dna* function you would want to use *as.matrix* followed by `as.alignment` and then the `as.DNAbin` to create a `DNAbin` object for the `dist.dna`.

# Analytic utilities

Once you have masked the sequence, you can then ask questions about the properties of that sequence. For example, you can look at the alphabet frequency of that sequence. The alphabet frequency will only be for the masked sequence.

```{r}
alphabetFrequency(autoMasked)
```

You can also calculate a consensus matrix, extract the consensus string or look at the consensus views. These methods too will all consider the masking when you run them.

```{r}
consensusMatrix(autoMasked, baseOnly=TRUE)[, 84:90]
substr(consensusString(autoMasked),80,130)
consensusViews(autoMasked) 
```

You can also cluster the alignments based on their distance to each other. Because you must pass in a DNAStringSet, the clustering will also take into account the masking. So for example, you can see how clustering the unmasked `DNAMultipleAlignment` will draw a funky looking tree.

```{r}
sdist <- stringDist(as(origMAlign,"DNAStringSet"), method="hamming") 
clust <- hclust(sdist, method = "single")
pdf(file="badTree.pdf") 
plot(clust) 
dev.off() 
```

But, if we use the gap-masked `DNAMultipleAlignment`, to remove the long uninformative regions, and then make our plot, we can see the real relationships.

```{r}
sdist <- stringDist(as(autoMasked,"DNAStringSet"), method="hamming") 
clust <- hclust(sdist, method = "single") 
pdf(file="goodTree.pdf") 
plot(clust) 
dev.off() 
```

```{r}
fourgroups <- cutree(clust, 4) 
fourgroups
```

In the "good" plot, the Salmon sequence is once again the most distant which is what we expect to see. A closer examination of the sequence reveals that the similarity between the mouse, rat and human sequences was being inflated by virtue of the fact that those sequences were simply much longer (had more information than) the other species represented. This is what caused the "funky" result. The relationship between the sequences in the funky tree was being driven by extra "length" in the rodent/mouse/human sequences, instead of by the similarity of the conserved regions.

# Exporting to file

One possible export option is to write to fasta files If you need to write your *MultipleAlignment* object out as a fasta file, you can cast it to a *DNAStringSet* and then write it out as a fasta file like so:

```{r eval=FALSE}
DNAStr = as(origMAlign, "DNAStringSet")
writeXStringSet(DNAStr, file="myFile.fa")
```

One other format that is of interest is the Phylip format. The Phylip format stores the column masking of your object as well as the sequence that you are exporting. So if you have masked the sequence and you write out a Phylip file, this mask will be recorded into the file you export. As with the fasta example above, any rows that you have masked out will be removed from the exported file.

```{r eval=FALSE}
write.phylip(phylipMAlign, filepath="myFile.txt")
```

# Session Information

All of the output in this vignette was produced under the following conditions:

```{r}
sessionInfo()
```
