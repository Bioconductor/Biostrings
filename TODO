Some R problems that maybe worth reporting:

- Loading a serialized XStringViews object without prior loading the Biostrings
  package seems to have problems: the object loads, but, when I try to display
  it, then nothing is printed and the prompt doesn't come back either (unless I
  CTRL C).

- rowSums() and colSums() should return integer vectors when applied on
  an integer matrix.


In 2.9
======

Reduce the depenencies by suggesting 1 genome only (not 2) or even better
by putting a single sequence in the data folder.

CONTAINERS

- Remove the XRaw class when all the BSgenome data packages have been rebuilt
  to use the new RawPtr class.

- Add "unique" method for IRanges objects.

- Add "baseXStringSubtype" methods for XStringViews, XStringSet and
  MaskedXString objects and replace use of "baseClass" by use of
  "baseXStringSubtype".

- XStringSet objects:
    o Support this: DNAStringSet(x, start=c(1,5), end=c(3,7)) when x is a
      single string (character or XString). The result should be a DNAStringSet
      object of the length of 'start' (or 'end').
    o Fix validObject() for XStringSet objects (currently broken).
    o DNAStringSet(x) should not do anything when x is already a DNAStringSet
      _instance_ (class(x) == "DNAStringSet").
    o Add methods for XStringSet objects everywhere there are methods defined
      for XStringViews objects (matchPattern, countPattern, etc...).
      Make them work in a vectorized fashion for XStringSet objects.
    o Add "==" method for XStringSet objects.
    o Try to speed up "show" method for XStringSet objects.

- Define a DNAorRNA class (or NucleotideString) that is the union of the
  DNAString and RNAString classes (use a union class for this or "do it by
  hand" by defining this as a virtual class and by having the DNAString
  and RNAString classes derived from it). Then use it to simplify code like:
    setMethod("alphabetFrequency", "DNAString", ...)
    setMethod("alphabetFrequency", "RNAString", ...)
  These 2 methods can be replaced by a single method:
    setMethod("alphabetFrequency", "NucleotideString", ...)
  Also this:
    if (is(x@subject, "DNAString") || is(x@subject, "RNAString")) ...
  can be replaced by:
    if (is(x@subject, "NucleotideString")) ...
  Etc...

C-LEVEL FACILITIES

- match_reporting.c: use the *_MRMODE codes defined in Biostrings_define.h
  instead of the current magic values used all over the place.

- Code cleaning: use _get_XString_asRoSeq() in every C routine that receives
  an XString argument. This reduces the number of args that need to be passed
  and makes the code much cleaner. See XString_match_pattern() for an example.

UTILITIES

- Move adjacentViews() to the IRanges package: this function can operate on
  any kind of Views object.

- Add "order", "sort", "duplicated", "unique" and "patternFrequency" methods
  for XStringSet and XStringViews objects. Also, for completeness, the "<=",
  ">=", "<" and ">" operators between XString objects should be provided.
  Note that Martin's srsort() from the ShortRead package is much faster
  than sortDNAString() from the old Biostrings 1 package:

    library(drosophila2probe)
    dict0 <- DNAString(drosophila2probe$sequence[1:100000])

  On george1:

    sortDNAString(dict0) # 1.053 sec. (R-2.7.1 + Biostrings 1.4.0)

    srsort(dict0) # 0.097 sec. (R-2.8 + Biostrings 2.9 + ShortRead 0.1)

  srsort() uses standard C qsort() internally.
  It might be possible to be even faster by building a prefix tree (like
  for the Aho-Corasick algo) but that will probably be at the cost of
  using much more memory.

- Add an xsmatch() function that would behave like standard base::match()
  but on XString objects (2nd arg 'table' must be an XStringSet object).
  When 'x' is a single string, 'xsmatch(x, table)' would return:

    ii <- nchar(x) == width(table) &
          isMatching(x, Biostrings:::super(table), start(table))
    which(ii)[1]

  although this is not optimal because isMatching() is doing too many
  comparisons when it could in fact bail out early.

- Add functions for translating DNA or RNA into AA.

- Use subseq() instead of subXString(). Remove subXString.R file.

- Add 'baseOnly' arg to consmat(). Rework the implementation (currently
  very inefficient). Another approach to providing consmat()'s functionality
  could be to add a 'bycol' (or by 'byCycle', or 'byPos") argument to
  alphabetFrequency(). When 'x' is an XStringSet object,
  alphabetFrequency(x, byCycle=TRUE) would return what Martin's
  alphabetByCycle() function currently returns.

- Finish C implemntation of read.XStringViews()

- Maybe make strrev() a "reverse" method for character objects.

- Add a new generic that combines a subject and an IRanges (or IRanges-like)
  object to return an XStringViews object. The IRanges-like object could be
  MIndex object and the method for it would do as if it had received
  unlist(MIndex). Currently my problem is that I can't come up with a good
  name for such generic :-/ Maybe I could just use views(subject, x) for
  this (dispatch would be on x, not subject). And the current views function
  could be renamed (or maybe it's not needed at all, maybe a fancy
  new("IRanges", ...) could replace it).

STRING MATCHING

- Add a no.match.length argument to gregexpr2() that is FALSE by
  default so gregexpr(pattern, text, fixed=TRUE) is more interchangeable
  with gregexpr2(pattern, text) and use no.match.length=TRUE in matchPattern's
  internal code.

- When algo="auto", use "naive_inexact" instead of "shift-or" when max.mismatch
  is high (e.g. >= 8, finding the exact cut-value requires some testing).
  Correct Robert's RBioinf book reporting that the performance decrease
  significantly when max.mismatch becomes to large. Should not be the case
  anymore.

- Add some convenience function (e.g. a wrapper to .valid.algos()) to let the
  curious user know which algos are available/used for a given search problem.

- Rework findPalindromes() (and findComplementedPalindromes()) so that they
  return maximum palindromes only.

- matchPDict()/countPDict()/whichPDict():

  o _match_ACtree() doesn't need to walk until the end of the subject: it could
    stop when the number of remaining chars to read is < to the difference
    between the depth of the AC tree (i.e. the width of the Trusted Band) and
    the current depth. This should speed up matchPDict()/countPDict()/whichPDict()
    substantially when the length of the subject is very small. A typical use
    case where this could be of great benefit is when finding the neighbors of a
    given pattern with e.g. whichPDict(pdict, pdict[[99]], max.mismatch=2).

  o Implement the skip.invalid.patterns arg in PDict() (so the user can build
    a PDict object from Solexa data that would contain Ns if he wants, reads
    with an N would just be skipped).

  o Implement "duplicated" and "patternFrequency" methods for PDict objects
    with a head or a tail. Add 'freq' arg (default FALSE) to patternFrequency()
    like for alphabetFrequency().

  o Added the all.names=TRUE arg to countPDict() with a warning when the
    user specifies it and the PDict object has no name.
    With this countPDict(..., all.names) should be exactly equivalent to
    countIndex(matchPDict(...), all.names)

  o startIndex() is broken on the MIndex object returned by a call to
    matchPDict() on a PDict object with a head or a tail.

  o extractAllMatches() fails on a very big MIndex object (can't allocate
    vector of size 5.2Gb).

  o C code improvement: no need to use temporrary storage for 'dups_buf' and
    'match_count' in match_pdict.c, store directly in the returned
    INTEGER vector.

  o MIndex objects: at some point the user will want to be able to combine
    "compatible" MIndex objects. 2 MIndex objects are "compatible" if they
    are describing 2 set of matches coming from the same original dict and on
    the same target (subject). In practice, it will be enough that they have
    the same index i.e. they have the same pids() or, if the pids() is NULL,
    they have the same length.
    Then methods like "union", "rangesect", "setdiff", "setequal", etc...
    could be defined. The set operation would be performed between the 2
    subsets of matches of each input pattern. Of course, 2 matches are
    considered equal if their start/end are the same.

  o Make reverseComplement() work on a PDict object.

  o GenomeSearching.Rnw vignette: add section about inexact matching with
    matchPDict().

  o Compare with other software for fast alignement and assembly:
      Vmatch (http://www.vmatch.de/)
      Maq (http://maq.sourceforge.net/)
      MUMmer (http://mummer.sourceforge.net/)

STRING ALIGNMENT

MISCELLANEOUS

- Update the CHANGES file.


In 2.11
=======

- Compare NAMESPACE + list of aliases in Rd files from Biostrings 1 and 2
  make sure no important feature has been lost.

- Remove the Biostrings 1 subdir.

- Look at apse.c in R/src/main for Levenshtein. It's coming from
    http://search.cpan.org/dist/String-Approx/
  and is what Perl and Python are using.
  It should stop and return an error code after some max.distance has been
  reached. We definitely want to be able to do this if we're going to use it
  on the millions of elements of the head and tail of a TB_PDict object.

- Change signature of matchPattern() (and of friends too, maybe): add a
  'min.mismatch' arg.

- Have the "XStringViews" method for XString objects support the 'collapse' arg.

- Maybe: add a specific containers for results returned by matchPattern
  (and family). Would derive from the XStringViews class with at least one
  additional slot, the @call slot (of type "language"), that would contain
  the value of match.call(), so that one knows what parameters were supplied
  for a given matching task.

- readFASTA(): remove warning when strip.desc is missing.

- Merge ~rgentlem/tmp/EMBOSS-3.0.0/emboss/matcher.c (Huang & Miller
  alignment algo) into Biostrings.

- An old Robert request: "have a look at GeneR, and see if there are
  any other packages that do sequence matching, and describe, in one page or
  so, what the differences are between the packages (also some notion of speed
  and size, how well do they work on different inputs)".


Later
=====

- Why doesn't sapply or lapply work for an XStringViews object (it didn't
  work either for BioString objects). Isn't it enough that these objects
  are subsettable?

- Restore the test units.

- Fix pb with length(x) <- 2 screwing up x if it's an XString or XStringViews
  object (prevent people of doing this by defining the replacement version
  of the length method and issuing an error).

- Still have to think about it (Robert suggestion): make [[ work on "out
  of limits" views with a warning (we keep issuing an error only when the
  view is all blank).

- Merge SuffixTree package from Robert.

